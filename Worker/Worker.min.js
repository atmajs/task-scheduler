include.setBase(include.location);

include.pauseStack();

include.routes({});

include.register({
    js: [ {
        id: "/src/logger.js",
        url: "/src/logger.js",
        parent: include.url || "/"
    }, {
        id: "/src/*.es6.package",
        url: "/src/*.es6.package",
        parent: include.url || "/"
    }, {
        id: "/src/Runner.es6",
        url: "/src/Runner.es6",
        parent: "/src/*.es6.package"
    }, {
        id: "/src/Worker.es6",
        url: "/src/Worker.es6",
        parent: "/src/*.es6.package"
    }, {
        id: "/src/source/Socket.es6",
        url: "/src/source/Socket.es6",
        parent: "/src/Worker.es6"
    }, {
        id: "/src/utils/io.es6",
        url: "/src/utils/io.es6",
        parent: "/src/source/Socket.es6"
    } ]
});

!function() {
    include.embed("../Utils/Utils.js", "../Model/Model.js").js("src/logger.js::Logger", "src/*.es6.package::Lib").done(function(resp) {
        include.exports = resp.Lib.Worker;
    });
}();

include.setCurrent({
    id: "/src/logger.js",
    namespace: "",
    url: "/src/logger.js"
});

!function() {
    include.exports = logger.create("Worker");
}();

include.getResource("/src/logger.js", "js").readystatechanged(3);

include.setCurrent({
    id: "/src/*.es6.package",
    namespace: "",
    url: "/src/*.es6.package"
});

!function() {
    include.js("Runner.es6::Runner", "Worker.es6::Worker").done(function(resp) {
        include.exports = resp;
    });
}();

include.getResource("/src/*.es6.package", "js").readystatechanged(3);

include.setCurrent({
    id: "/src/Runner.es6",
    namespace: "",
    url: "/src/Runner.es6"
});

!function() {
    "use strict";
    include.use("Model.HistoryTask", "Logger").done(function(resp, HistoryTask, log) {
        include.exports = Class("Worker.Runner", {
            Base: Class.EventEmitter,
            Construct: function(worker) {
                this.stack = [];
                this.worker = worker;
            },
            config: {
                parallel: 10,
                retries: 4
            },
            stack: null,
            run: function(app, historyTask) {
                log.trace("Execute task", historyTask.task.name.bold);
                this.stack.push(historyTask);
                historyTask.task.exec.process(app, historyTask.task).done(task_doneDelegate(this, historyTask)).fail(task_failDelegate(this, historyTask));
            },
            hasSlot: function() {
                return this.stack.length < this.config.parallel;
            }
        });
        function task_doneDelegate(runner, task) {
            return function() {
                task_complete(runner, task);
            };
        }
        function task_failDelegate(runner, task) {
            return function(error) {
                task.error = error;
                task_complete(runner, task);
            };
        }
        function task_complete(runner, historyTask) {
            log("Task %s completed in %d ms", historyTask.task.name.bold, new Date() - historyTask.start);
            var i = runner.stack.indexOf(historyTask);
            if (i === -1) log.error("No task in stack", runner.stack);
            runner.stack.splice(i, 1);
            runner.trigger("task:completed", historyTask, {
                tasks: runner.stack.length
            });
        }
    });
}();

include.getResource("/src/Runner.es6", "js").readystatechanged(3);

include.setCurrent({
    id: "/src/Worker.es6",
    namespace: "",
    url: "/src/Worker.es6"
});

!function() {
    "use strict";
    include.use("Logger").js("Runner.es6", "source/Socket.es6").done(function(resp, log) {
        var Worker = include.exports = Class({
            Construct: function(source) {
                var $__0 = this;
                this.runner = new resp.Runner(this);
                this.source = source;
                this.source.on("task:run", function(app, historyTask) {
                    return $__0.runner.run(app, historyTask);
                });
                this.runner.on("task:completed", function(historyTask, info) {
                    return $__0.source.complete(historyTask, info);
                });
            },
            Static: {
                connect: function(config) {
                    var dfr = new Class.Deferred();
                    resp.Socket.connect(config).fail(function(error) {
                        var msg = logger.formatMessage("Can`t connect to the master Queue", error);
                        log.error(msg);
                        dfr.reject(error, msg);
                    }).done(function(source) {
                        log("Connected to server".green, config.port);
                        dfr.resolve(new Worker(source));
                    });
                    return dfr;
                }
            }
        });
    });
}();

include.getResource("/src/Worker.es6", "js").readystatechanged(3);

include.setCurrent({
    id: "/src/source/Socket.es6",
    namespace: "",
    url: "/src/source/Socket.es6"
});

!function() {
    "use strict";
    include.use("Model", "Logger").js("../utils/io.es6::IoUtils").done(function(resp, Model, log) {
        var Socket = include.exports = Class({
            Base: Class.EventEmitter,
            Construct: function(socket) {
                var $__0 = this;
                this.socket = socket;
                socket.on("hasNewTasks", function() {
                    return $__0.requestTask().done(function(app, task) {
                        return $__0.trigger("task:run", app, task);
                    });
                }).on("task:run", function(app, historyTask, done) {
                    $__0.trigger("task:run", app, historyTask);
                    done(true);
                });
            },
            Static: {
                connect: function(config) {
                    var dfr = new Class.Deferred();
                    resp.IoUtils.connect(config).fail(dfr.rejectDelegate()).done(function(socket) {
                        log.trace("Worker Socket | connected".green);
                        dfr.resolve(new Socket(socket));
                    });
                    return dfr;
                }
            },
            requestTask: function() {
                var dfr = new Class.Deferred();
                this.socket.emit("task:pluck", "workerDummy", function(app, task) {
                    if (null == task) {
                        dfr.reject("empty");
                        return;
                    }
                    dfr.resolve(app, new Model.HistoryTask(task));
                });
                return dfr;
            },
            log: function(historyTask, message) {
                var dfr = new Class.Deferred();
                this.socket.emit("task:log", historyTask.toJSON(), message, dfr.resolveDelegate());
                return dfr;
            },
            complete: function(historyTask, workerInfo) {
                var dfr = new Class.Deferred();
                this.socket.emit("task:completed", historyTask.toJSON(), workerInfo, dfr.resolveDelegate());
            }
        });
    });
}();

include.getResource("/src/source/Socket.es6", "js").readystatechanged(3);

include.setCurrent({
    id: "/src/utils/io.es6",
    namespace: "",
    url: "/src/utils/io.es6"
});

!function() {
    "use strict";
    var io_connect, io_clean;
    init();
    include.exports = {
        connect: io_connect,
        clean: io_clean
    };
    function init() {
        var dfr, client;
        io_clean = function() {
            if (null == dfr) return;
            if (null == dfr._resolved) {
                dfr = null;
                return;
            }
            var socket = dfr._resolved[0];
            socket.socket.disconnectSync();
            dfr = null;
        };
        io_connect = function(config) {
            if (dfr) return dfr;
            dfr = new Class.Deferred();
            if (null == client) client = getClient();
            var port = config.port, host = config.host, url = config.url;
            if (null == url) url = (host || "http://localhost") + ":" + (port || 5811);
            url += "/task-scheduler-worker";
            var socket = client.connect(url, {
                "connect timeout": 2e3,
                "force new connection": true
            });
            socket.on("connect", function() {
                dfr.resolve(socket);
            }).on("error", function(error) {
                socket.socket.disconnectSync();
                socket.socket.removeAllListeners();
                dfr && dfr.reject(error);
            });
            return dfr;
        };
        function getClient() {
            var _io = global.io;
            delete global.io;
            var client = require("socket.io-client");
            global.io = _io;
            return client;
        }
    }
}();

include.getResource("/src/utils/io.es6", "js").readystatechanged(3);

include.resumeStack();